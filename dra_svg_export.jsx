#target illustratorvar debug = false;var layerNames = ({    "#9faa44":"Major",    "#b7b7b7":"Store",    "#717174":"Kiosk",    "#e5e5e5":"Floor",    //"#000000":});var maxSize = 1000;app.userInteractionLevel = UserInteractionLevel.DONTDISPLAYALERTS;var svgExportOptions = new ExportOptionsSVG();svgExportOptions.includeFileInfo = false;svgExportOptions.documentEncoding = SVGDocumentEncoding.UTF8;svgExportOptions.optimiseForSVGViewer = false;svgExportOptions.preserveEditability = false;svgExportOptions.embedRasterImages = true;svgExportOptions.DTD = SVGDTDVersion.SVGTINY1_2;svgExportOptions.cssProperties = SVGCSSPropertyLocation.PRESENTATIONATTRIBUTES;var executionCancelled;var myProgressBarWindow;var myProgressBar; var myProgressBar2; File.prototype.partname = function() {    var dotPosition=this.displayName.lastIndexOf(".");    return this.displayName.substring(0,dotPosition);}  File.prototype.extension = function() {    var dotPosition=this.displayName.lastIndexOf(".");    return this.displayName.substring(dotPosition+1).toLowerCase();}                     Folder.prototype.extension = function() {    return "";}Folder.prototype.createOnce = function() {    if(!this.exists) this.create();    return this;}Folder.prototype.getAllAiFiles = function() {    var allFiles = this.getFiles(isAiFile);        var allFolders = this.getFiles(isFolder);    if (allFolders !== null) {        for (var i = 0; i < allFolders.length; i++)        {            allFiles=allFiles.concat(allFolders[i].getAllAiFiles());        }    }    return allFiles;}function _main(){    var processActiveFlag = false;    if(app.documents.length)     {       processActiveFlag = confirm("Process active document?");     }    if(processActiveFlag)    {        myProgressBarWindow = new Window('palette', 'Progress', [150, 150, 600, 330]);         myProgressBar2 = myProgressBarWindow.add('progressbar', [20, 80, 410, 105], 0, 10);         var progressCancelButton = myProgressBarWindow.add('button', [200, 125, 270, 145], 'Cancel');        progressCancelButton.onClick = function()        {            alert("Execution cancelled by user");            executionCancelled = true;            myProgressBarWindow.close();        }        myProgressBarWindow.show();        processDocument(app.activeDocument);        try{myProgressBarWindow.close();}catch(e){}        alert("Done");    }    else    do{        var sourceFolder = Folder.selectDialog("Please select source folder");        if(!sourceFolder) break;        var allSources = sourceFolder.getAllAiFiles();        var executionCancelled=false;        myProgressBarWindow = new Window('palette', 'Progress', [150, 150, 600, 330]);        myProgressBar = myProgressBarWindow.add('progressbar', [20, 35, 410, 60], 0, allSources.length);         myProgressBar2 = myProgressBarWindow.add('progressbar', [20, 80, 410, 105], 0, 10);         var progressCancelButton = myProgressBarWindow.add('button', [200, 125, 270, 145], 'Cancel');        progressCancelButton.onClick = function()        {            alert("Execution cancelled by user");            executionCancelled = true;            myProgressBarWindow.close();        }        myProgressBar.value=0;          myProgressBarWindow.show();        for(var i=0;i<allSources.length;i++)            try{                if(executionCancelled) break;                myProgressBar.value++;                myProgressBarWindow.text = "Processing "+(i+1)+" out of "+allSources.length;                myProgressBarWindow.hide(); myProgressBarWindow.show();                var docRef = app.open(allSources[i],DocumentColorSpace.RGB);                processDocument(docRef);                docRef.close(SaveOptions.DONOTSAVECHANGES);            }catch(e){alert(e)}        try{myProgressBarWindow.close();}catch(e){}        alert("Done");    }while(false);}function processDocument(docRef){    app.redraw();    var allLayers = docRef.layers;    myProgressBar2.value = 0;    myProgressBar2.maxValue = allLayers.length-1;    myProgressBarWindow.hide(); myProgressBarWindow.show();    for(var i=0;i<allLayers.length;i++)    {        app.activeDocument = docRef;            var currLayer = allLayers[i];        if(currLayer.locked) continue;        processLayer(docRef, currLayer);    }}function processLayer(docRef, layer){    var progressText = myProgressBarWindow.text + " - ";    app.selection=undefined;    var maxX;    var minX;    var maxY;    var minY;    myProgressBar2.value++;    myProgressBarWindow.text = progressText+"Getting artboard bounds for layer "+layer.name;    myProgressBarWindow.hide(); myProgressBarWindow.show();    //  myProgressBarWindow.update();    for(var j=0;j<layer.pageItems.length;j++)    {        if(layer.pageItems[j].locked) continue;        layer.pageItems[j].selected=true;        var currentRect=layer.pageItems[j].visibleBounds;        if(j==0)        {            maxX=Math.max(currentRect[0],currentRect[2]);            minX=Math.min(currentRect[0],currentRect[2]);            maxY=Math.max(currentRect[1],currentRect[3]);            minY=Math.min(currentRect[1],currentRect[3]);        }        else {            maxX=Math.max(maxX,currentRect[2]);            minX=Math.min(minX,currentRect[0]);            maxY=Math.max(maxY,currentRect[1]);            minY=Math.min(minY,currentRect[3]);        }    }    var newHeight = Math.abs(maxY-minY);    var newWidth = Math.abs(maxX-minX);    var scale = 1;    if (newHeight > newWidth) {        scale = 100 * maxSize / newHeight;    } else {        scale = 100 * maxSize / newWidth;    }        newHeight = newHeight * scale;    newWidth = newWidth * scale;    resize(layer, scale);        app.copy();    app.selection=undefined;    //create new doc    var targetDoc = app.documents.add(DocumentColorSpace.RGB,newWidth,newHeight);    app.activeDocument = targetDoc;    app.redraw();    var firstLayer = targetDoc.layers[0];    var newLayer = targetDoc.layers.add();    app.redraw();    app.redraw();    newLayer.name = layer.name;    firstLayer.remove();    app.paste();    app.redraw();    //targetDoc.fitArtboardToSelectedArt(0);    app.selection=undefined;    app.redraw();    myProgressBarWindow.text = progressText+"Sorting items for "+layer.name;    myProgressBarWindow.hide(); myProgressBarWindow.show();    //  myProgressBarWindow.update();    var allPageItems = sortByColor(targetDoc.pageItems);    myProgressBarWindow.text = progressText+"Grouping by color for "+layer.name;    myProgressBarWindow.hide(); myProgressBarWindow.show();    // myProgressBarWindow.update();    for(var k=0; k<allPageItems.length; k++)    {        var currItems = allPageItems[k].items;               var targetLayer;        try{            targetLayer= newLayer.layers.getByName(allPageItems[k].hexName);        }catch(e){                targetLayer= newLayer.layers.add();                app.redraw();                targetLayer.name = allPageItems[k].hexName;                //log(layerNames[allPageItems[k].hexName]);                if(layerNames[allPageItems[k].hexName]) targetLayer.name = layerNames[allPageItems[k].hexName].toUpperCase();        }        for(var j=0;j<currItems.length;j++)        {            currItems[j].move(targetLayer,ElementPlacement.INSIDE);        }    }    var targetSvgFolder = Folder(docRef.fullName.parent+"/"+docRef.fullName.partname()).createOnce();    var targetSvgFile = File(targetSvgFolder +"/"+layer.name+".svg");     //log(targetSvgFile);    targetDoc.exportFile(targetSvgFile, ExportType.SVG, svgExportOptions);    targetDoc.close(SaveOptions.DONOTSAVECHANGES);}function resize(layer, scale){    for(var i = 0; i < layer.pageItems.length; i++)    {        if (layer.pageItems[i].locked)            continue;        layer.pageItems[i].resize(            scale, // x            scale, // y            true, // changePositions            true, // changeFillPatterns            true, // changeFillGradients            true, // changeStrokePattern            scale , // changeLineWidths            Transformation.DOCUMENTORIGIN); // scaleAbout    }}function sortByColor(pageItems){    var result = new Object();    for(var i=0;i<pageItems.length;i++)    try{        var currItem = pageItems[i];        var currColor;        var zOrder;        if (currItem.typename=="CompoundPathItem")        {            var subItem = currItem.pathItems[0];            zOrder = subItem.zOrderPosition;            if(subItem.filled) currColor = subItem.fillColor;            else if(subItem.stroked) currColor = subItem.strokeColor;        }        else        {            if(currItem.filled) currColor = currItem.fillColor;            else if(currItem.stroked) currColor = currItem.strokeColor;            zOrder = currItem.zOrderPosition;        }        if(currColor!=undefined)        {            var hexName = colorAsString(currColor);            if(result[hexName]==undefined)                 result[hexName] = ({zOrder:zOrder,hexName:hexName,items:[]});            if (currItem.parent.typename!="CompoundPathItem")                result[hexName].items.push(currItem);        }    }catch(e){}    var resultArray=[];    for(var obj in result)    {        resultArray.push(result[obj]);    }    //log(resultArray);    return resultArray.sort(sortByZorder);}function colorAsString(c){    var result="";    try{                var color = c;        var newColor;        var sourceSpace;        var targetSpace;        var colorComponents;        switch(c.typename)        {            case "RGBColor": sourceSpace = ImageColorSpace.RGB; colorComponents=[c.red,c.green,c.blue]; break;            case "CMYKColor": sourceSpace = ImageColorSpace.CMYK; colorComponents=[c.cyan,c.magenta,c.yellow,c.black]; break;            case "LabColor": sourceSpace = ImageColorSpace.LAB; colorComponents=[c.l,c.a,c.b]; break;            case "GrayColor": sourceSpace = ImageColorSpace.GrayScale; colorComponents=[c.gray]; break;        }        targetSpace=ImageColorSpace.RGB;        /*        if(sourceSpace!=null)        {            var newColorComponents = app.convertSampleColor(sourceSpace, colorComponents, targetSpace,ColorConvertPurpose.previewpurpose);            newColor = new RGBColor();             newColor.red = newColorComponents[0];             newColor.green = newColorComponents[1];            newColor.blue = newColorComponents[2];            color = newColor;        }        */            result = "#";        for(var i=0;i<colorComponents.length;i++)        {            var myColor=Math.round(colorComponents[i]).toString(16);            if (myColor.length==1) myColor="0"+myColor;            result+=myColor;                }    }catch(e){}    return result;}function sortBy_zOrder(a, b) {    if(a.zOrderPosition==undefined || b.zOrderPosition==undefined){        return 0;    }    var x = Number(a.zOrderPosition);    var y = Number(b.zOrderPosition);    return ((x < y) ? -1 : ((x > y) ? 1 : 0));}function sortByZorder(a,b) //reversed{    var result = 0;    try{        if (a.zOrder > b.zOrder) result = 1;        if (a.zOrder < b.zOrder) result = -1;    }catch(e){};    return result;}function isAiFile(obj){    var result = false;    if (obj.constructor.name === "File" && !obj.hidden && obj.extension()=="ai") result = true;    return result;}function isFolder(obj){    var result = false;    if (obj.constructor.name === "Folder") result = true;    return result;}function log(obj){    if (debug)    {        $.writeln("------");        try{               $.writeln(obj + " - "+obj.toSource());            }catch(e){$.writeln(obj)}        $.writeln("------");    }}_main();